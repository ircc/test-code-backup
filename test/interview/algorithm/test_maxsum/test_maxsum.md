#最大连续子串和

##问题描述
在长度为n的整形数组中，求连续子串的和的最大值，要求复杂度为O(n)。

##基本思路
1. 如果全部为正数则只需将所有值相加即可
2. 如果全部为负数则只需求出最大值即可
3. 将子串从零位开始逐步相加，保存和的最大值；如果某个和小于等于零则说明现在位与之前位不能得出最大子串，则丢弃之前位从当前位重新开始计算和的最大值并保存
4. 保存的最大值则为所有和的最大值

##实现方法
假设数组int szArray[n], 实现如下：
1. 从0位开始遍历数组szArray，并在循环中实现2 3 4 5步
2. 将值与临时变量iTemp(累加和)相加并赋予iTemp(iTemp+=值)
3. 如果iTemp大于零说明有可能是最大值，可以继续累加
4. 如果iTemp小于或等于零说明之前的数据不能与之后的数据造成最大和，反而使最大和变小，所以丢弃之前值从当前位开始计算
5. 比较iTemp与iSum(最大值保存变量)大小，并将大的保存至iSum
5. 直到循环结束，此时iSum即为所求


##注意事项
###负数在内存中的表示，int类型取值范围 
我们拿32位int型来讲，首位是符号位，0表示正数，1表示负数，后面31位用来表示数值

1. 正数的补码和原码相同。

2. 负数的补码是对其原码逐位取反，但符号位除外；然后整个数加1。
    比如 -1这个数  
    原码：1000 0000, 0000 0000, 0000 0000, 0000 0001  
    取反：1111 1111, 1111 1111, 1111 1111, 1111 1110  
    加1 ：1111 1111, 1111 1111, 1111 1111, 1111 1111  
    
    上面最后结果就是-1的补码
    
3. int取值范围

    -2^31 ~ 2^31-1  
    为什么负数是 -2^31 而不是-2^31-1呢?  
    因为规定了1000 0000, 0000 0000, 0000 0000, 0000 0000这个特殊的数（本来是-0的）为-2^31，所以负数就多一个

4. INT_MAX和INT_MIN宏  
    <limits.h>中有INT_MAX和INT_MIN的宏定义可直接使用。    
    或者自行定义宏：  

		#define INT_MAX 0x7fffffff
		#define INT_MIN 0x80000000  
		
		INT_MAX = 2147483647
		INT_MIN = -2147483648
    
    
    
    
    
