# 算法的复杂度

算法的时间复杂度和空间复杂度合称为算法的复杂度。

## 时间复杂度

### 定义

在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。

### 计算方法
求解算法的时间复杂度的具体步骤是：

1. 找出算法中的基本语句；  
	算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。  

2. 计算基本语句的执行次数的数量级；  
	只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。

3. 用大Ο记号表示算法的时间性能。  
	将基本语句执行次数的数量级放入大Ο记号中。  
	如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加。


1. 一般情况下，算法的基本操作重复执行的次数是模块n的某一个函数f(n)，因此，算法的时间复杂度记做：T(n)=O(f(n))  
	
	分析：随着模块n的增大，算法执行的时间的增长率和 f(n) 的增长率成正比，所以 f(n) 越小，算法的时间复杂度越低，算法的效率越高。

2. 在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出 T(n) 的同数量级（它的同数量级有以下：1，log2n，n，n log2n ，n的平方，n的三次方，2的n次方，n!），找出后，f(n) = 该数量级，若 T(n)/f(n) 求极限可得到一常数c，则时间复杂度T(n) = O(f(n))

例：算法：

	
    for(i=1; i<=n; ++i)
    {
        for(j=1; j<=n; ++j)
        {
            c[i][j] = 0;                        //该步骤属于基本操作执行次数：n的平方次
            for(k=1; k<=n; ++k)
                c[i][j] += a[i][k] * b[k][j];  //该步骤属于基本操作执行次数：n的三次方次
        }
    }


   则有 T(n) = n 的平方+n的三次方，根据上面括号里的同数量级，我们可以确定 n的三次方 为T（n）的同数量级  
   则有 f(n) = n的三次方，然后根据 T(n)/f(n) 求极限可得到常数c  
   则该算法的时间复杂度：T(n) = O(n^3) 注：n^3即是n的3次方。  
   第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n^2)，第三个for循环的时间复杂度为Ο(n^3)  

常见的时间复杂度，按数量级递增排列依次为：常数阶O(1)、对数阶O(log2n)、线性阶O(n)、线性对数阶O(nlog2n)、平方阶O(n^2)、立方阶O(n^3)、k次方阶O(n^k)、指数阶O(2^n)

#### 算法时间复杂度-常数阶O(1)

与问题的大小无关（n的多少），执行时间恒定的算法，我们称之为具有O(1)的时间复杂度，又叫常数阶

#### 算法时间复杂度-对数阶O(log2n)

    int count = 1;
    while (count < n)
    { 
        count = count * 2; /* 时间复杂度为O(1)的程序步骤序列 */
    }

由于每次count乘以2之后，就距离n更近了一分。
也就是说，有多少个2相乘后大于n，则会退出循环。
由2^x=n得到x=log2n。所以这个循环的时间复杂度为O(logn)。

#### 算法时间复杂度-线性阶O(n)

线性阶的循环结构会复杂很多。要确定某个算法的阶次，我们常常需要确定某个特定语句或某个语句集运行的次数。
因此，我们要分析算法的复杂度，关键就是要分析循环结构的运行情况。
下面这段代码，它的循环的时间复杂度为O(n)，因为循环体中的代码须要执行n次。

    int i;for (i = 0; i < n; i++)
    {   
        /* 时间复杂度为O(1)的程序步骤序列 */
    }


#### 算法时间复杂度-平方阶O(n^2)

下面例子是一个循环嵌套，它的内循环刚才我们已经分析过，时间复杂度为O(n)。

    int i, j;for (i = 0; i < n; i++)
    {   
        for (j = 0; j < n; j++)    
        {       
            /* 时间复杂度为O(1)的程序步骤序列 */   
        }
    }

而对于外层的循环，不过是内部这个时间复杂度为O(n)的语句，再循环n次。所以这段代码的时间复杂度为O(n^2)。

如果外循环的循环次数改为了m，时间复杂度就变为O(m×n)。

    int i, j;
    for (i = 0; i < m; i++)
    {    
        for (j = 0; j < n; j++)    
        {       
            /* 时间复杂度为O(1)的程序步骤序列 */    
        }
    }


所以我们可以总结得出，循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。
那么下面这个循环嵌套，它的时间复杂度是多少呢？

    int i, j;
    for (i = 0; i < n; i++)
    {   
        for (j = i; j < n; j++)  /* 注意j = i 而不是0 */   
        {       
            /* 时间复杂度为O(1)的程序步骤序列 */  
        }
    }

由于当i=0时，内循环执行了n次，当i=1时，执行了n-1次，……当i=n-1时，执行了1次。
所以总的执行次数为：用我们推导大O阶的方法，
第一条，没有加法常数不予考虑；
第二条，只保留最高阶项，因此保留n^2/2；
第三条，去除这个项相乘的常数，也就是去除1/2，最终这段代码的时间复杂度为O(n^2)。

#### 算法时间复杂度-推导大O阶

1. 用常数1取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项。
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数。得到的结果就是大O阶。


## 空间复杂度

一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分。　  



### 固定部分

这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。

### 可变空间

这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。
一个算法所需的存储空间用f(n)表示。S(n)=O(f(n))　　其中n为问题的规模，S(n)表示空间复杂度。






## 附加说明
### 对数

如果a的x次方等于N（a>0，且a不等于1），那么数X叫做以a为底N的对数（logarithm），记作x=log(a)N。其中，a叫做对数的底数，N叫做真数。  

一般情况下是不考虑空间复杂度的，空间复杂度并不是指所有的数据所占用的空间，而是使用的辅助空间的大小，比如两个矩阵的运算，在中间设置了一个中间矩阵来保存一些数据，这些空间叫做空间复杂度。空间复杂度的运算非常麻烦，一般简单的算法空间复杂度都是O(1)，比较复杂的会告知空间复杂度，记住就好了。






