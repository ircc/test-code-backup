#const用法



##定义
常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的。（当然，我们可以偷梁换柱进行更新：通过修改内存）



##目的
const 推出的初始目的，正是为了取代预编译指令，消除它的缺点，同时继承它的优点。



##主要作用

1. 可以定义const常量，具有不可变性。  
    例如：const int Max=100; Max++会产生错误;

2. 便于进行类型检查，使编译器对处理内容有更多了解，消除了一些隐患。  
    例如： void f(const int i) {……} 编译器就会知道i是一个常量，不允许修改；

3. 可以避免意义模糊的数字出现，同样可以很方便地进行参数的调整和修改。 同宏定义一样，可以做到不变则已，一变都变！
　　如(1)中，如果想修改Max的内容，只需要：const int Max=you want;即可！

4. 可以保护被修饰的东西，防止意外的修改，增强程序的健壮性。 还是上面的例子，如果在函数体内修改了i，编译器就会报错；
　　例如： void f(const int i) { i=10; //error! }

5. 可以节省空间，避免不必要的内存分配。  
    例如：

		#define PI 3.14159        //常量宏  
		const double Pi=3.14159;  //此时并未将Pi放入RAM中 ......
		double i=Pi;              //此时为Pi分配内存，以后不再分配！  
		double I=PI;              //编译期间进行宏替换，分配内存  
		double j=Pi;              //没有内存分配  
		double J=PI;              //再进行宏替换，又一次分配内存！     

	const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干份拷贝。

6. 提高了效率。  
	编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。

7. 为函数重载提供了一个参考。  
	
	    class A
    	{
        	......
	        void f(int i) {......}        //一个函数 
    	    void f(int i) const {......}  //上一个函数的重载
        	......
	    };

        
    
##使用const
1. 修饰一般常量  
    一般常量是指简单类型的常量。这种常量在定义时，修饰符const可以用在类型说明符前，也可以用在类型说明符后。
    例如： int const x=2;　　或　　const int x=2;  
    
2. 修饰常数组  
    定义或说明一个常数组可采用如下格式：
    
    　	int const a[5]={1, 2, 3, 4, 5};　
		const int a[5]={1, 2, 3, 4, 5}; 
        
3. 修饰常对象
    常对象是指对象常量，定义格式如下：  
        
        class A;
		const A a;
		A const a;    
	定义常对象时，同样要进行初始化，并且该对象不能再被更新，修饰符const可以放在类名后面，也可以放在类名前面

4. 修饰常指针  

		const int *A; //const修饰指向的对象，A可变，A指向的对象不可变 
		int const *A; 　 //const修饰指向的对象，A可变，A指向的对象不可变
		int *const A; 　 //const修饰指针A， A不可变，A指向的对象可变 
		const int *const A; //指针A和A指向的对象都不可变 	

5. 修饰常引用  
	使用const修饰符也可以说明引用，被说明的引用为常引用，该引用所引用的对象不能被更新。其定义格式如下：    

		const double & v;

6. 修饰函数的常参数  
    const修饰符也可以修饰函数的传递参数，格式如下：
    
        void Fun(const int Var);
        
    告诉编译器Var在函数体中的无法改变，从而防止了使用者的一些无意的或错误的修改。  
    
7. 修饰函数的返回值：  
    const修饰符也可以修饰函数的返回值，是返回值不可被改变，格式如下：
    
        const int Fun1(); 
        const MyClass Fun2();
        
8. 修饰类的成员函数：
    const修饰符也可以修饰类的成员函数，格式如下：
    
        class ClassName 
        {
        public:
        　 　int Fun() const;
             .....
         }；
         
    这样，在调用函数Fun时就不能修改类里面的数据
    
9. 在另一连接文件中引用const常量  
    
        extern const int i; //正确的引用
        extern const int j="10"; //错误！常量不可以被再次赋值
        
另外，还要注意，常量必须初始化！
例如：const int i="5"; 



##需要注意的地方


###const的初始化

* const常量定义时必须初始化  
* const数据成员的初始化只能在类的构造函数的初始化列表中进行。
* 要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static const
* const常量不能赋值给非const数据类型


###const修饰函数

####修饰参数的const

1. const 只能修饰输入参数  
    如果输入参数采用“指针传递”，那么加const 修饰可以防止意外地改动该指针。
    例如：void StringCopy(char *strDestination, const char *strSource);

2. 如果输入参数采用“值传递”，由于函数将自动产生临时变量用于复制该参数，该输入参数本来就无需保护，所以不要加const 修饰。  
    例如：不要将函数void Func1(int x) 写成void Func1(const int x)。

3. 对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。  
    例如：将void Func(A a) 改为void Func(const A &a)。  
    因为函数体内将产生A 类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间；“引用传递”仅借用一下参数的别名而已，不需要产生临时对象。

4. 对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。  
    例如：void Func(int x) 不应该改为void Func(const int &x)。   
    因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。
    
####修饰返回值的const

1. 如果给以“指针传递”方式的函数返回值加const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。  
    例如：函数const char * GetString(void);
    正确的用法是: const char *str = GetString();  //写为char *str = GetString();将出现编译错误

2. 如果函数返回值采用“值传递”方式，由于函数会把返回值复制到外部临时的存储单元中，加const 修饰没有任何价值。  
    例如：不要把函数int GetInt(void) 写成const int GetInt(void)。

3. 函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数



####类成员函数中const的使用  

任何不会修改数据成员的函数都应该声明为const 类型。如果在编写const 成员函数时，不慎修改了数据成员，或者调用了其它非const 成员函数，编译器将指出错误，这无疑会提高程序的健壮性。例如：

        int GetCount(void) const; // const 成员函数  
          
const 关键字只能放在函数声明的尾部，大概是因为其它地方都已经被占用了。

###const和指针
####const <类型> *<指针变量名>

该语句的作用是：定义指针变量所指数据值为常量，即：指针变量所指数据值不能改变，但指针变量值可以改变。例如:

        float x = 0, y = 0;
        const float *p = &x; //定义指针变量p所指数据值*p为常量
        *p = 25;             //错误，p所指变量x数据值不能用*p形式进行改变
        p = &y;              //正确，可改指针变量p的值
        x = 25;              //正确，变量x的值可以改变  

####<类型> * const <指针变量名>
该语句的作用是：定义指针变量值为常量，即：指针变量值不能改变，但指针变量所指数据值可以改变。例如：

        float x = 0,y = 0;
        float * const p = &x; //定义指针变量p的值为常量
        *p = 25;               //正确，p所指变量x数据值可以用*p形式进行改变
        p = &y;                //错误，指针变量p的值不能改变
        
####const <类型> * const <指针变量名>
该语句的作用是：定义指针变量值为常量，指针变量所指数据值为常量。即：指针变量值不能改变，指针变量所指数据值也不能改变。例如：

        float x = 0, y = 0;
        const float * const p = &x; //定义指针变量p为常量
        *p = 25;                    //错误，p所指变量x数据值不能用*p形式进行改变
        p = &y;                     //错误，不能改变指针变量p的值 

用这种形式定义指针变量，必须在定义时赋初值。

####注意：
1. 因为引用变量类同于指针变量，所以这三种定义形式完全适应于引用类型变量。
2. 定义const类型指针的目的是提高程序的安全性，用const 可限制程序随意修改指针值。
3. const 指针主要用作函数参数，以限制在函数体不能修改指针变量的值，或不能修改指针变量所指数据值。　























































